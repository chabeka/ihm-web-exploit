import { Injectable } from '@angular/core'
import { HttpClient, HttpErrorResponse, HttpHeaders } from '@angular/common/http';
import { Observable, catchError, map, throwError, of } from 'rxjs';
import { Environnement } from '../models/environnement.model';

// enregistrement Ã  la racine de l'application avec providedIn: 'root'
@Injectable({
	providedIn: 'root'
})
export class FaceSnapsService{
	
  httpOptions = {
    headers: new HttpHeaders({ 'Content-Type': 'application/json' })
  };

  private readonly urlSnaps = 'api/environnements.json'; 
  
  constructor(private http : HttpClient){};

  getAllFaceSnaps() : Observable<Environnement[]>{
    return this.http.get<Environnement[]>(this.urlSnaps);
  }
  /*
  getFaceSanpsById(faceSanpsId:number): FaceSnaps{
    //const faceSnap = this.tabFaceSnaps.find(faceSnap => faceSnap.id === faceSanpsId);
    this.getAllFaceSnaps().pipe(map(fs => fs.filter(snap => snap.id === faceSanpsId)))
                          .subscribe(data : any);
    if(faceSnap) {
      return faceSnap;
    } else {
      throw new Error('FaceSnap not found');
    }
  }

  snapFaceSnapsById(faceSnapsId:number, snapType: 'snap' | 'unsnap'): void {
    const faceSnap = this.getFaceSanpsById(faceSnapsId);
    snapType === 'snap' ? faceSnap.snaps++ : faceSnap.snaps--;
  }
  */

  getFaceSanpsById(nom : string): Observable<Environnement[]> {
    return this.getAllFaceSnaps().pipe(map(fs => fs.filter(s => s.nom === nom)));
  }

  getSnapByIdWithError(nom:string):Observable<Environnement| undefined>{
   
    return this.http.get<Environnement[]>(this.urlSnaps)
      .pipe(
        map(templates => {
          return templates.find(template => {
            return template.nom === nom;
          })
        }),
        catchError(this.handleError<Environnement>('getSnapByIdWithError'))
      );
  }

  getSnapById(nom:string):Observable<Environnement>{
   
    return this.http.get<Environnement[]>(this.urlSnaps)
      .pipe(
        map(templates => {
          return templates.find(template => {
            return template.nom === nom;
          })
        })
      ) as Observable<Environnement>;

  }
  updateHero(env: Environnement): Observable<any> {
    return this.http.put(this.urlSnaps, env, this.httpOptions).pipe(
      catchError(this.handleError<any>('updateHero'))
    );
  }

  /************************************************************************************************/
      /* handler */
  /************************************************************************************************/
  private handleError<T>(operation = 'operation', result?: T) {
    return (error: any): Observable<T> => {
  
      // TODO: send the error to remote logging infrastructure
      console.error(error); // log to console instead
  
      // Let the app keep running by returning an empty result.
      return of(result as T);
    };
  }

}