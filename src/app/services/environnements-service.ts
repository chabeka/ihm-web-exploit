import { Injectable } from '@angular/core'
import { HttpClient, HttpErrorResponse, HttpHeaders } from '@angular/common/http';
import { Observable, catchError, map, throwError, of, tap } from 'rxjs';
import { Environnement } from '../models/environnement.model';
import { FrontalEnv } from '../models/frontal-env.model';
import { Document } from '../models/document.model';

// enregistrement Ã  la racine de l'application avec providedIn: 'root'
@Injectable({
	providedIn: 'root'
})
export class EnvironnementsService{
	
  httpOptions = {
    headers: new HttpHeaders({ 'Content-Type': 'application/json' })
  };

  private readonly urlEnvironnements = 'api/environnements'; 
  private readonly frontalsUrl = 'api/frontals';
  private readonly documentsUrl = 'api/documents';
  
  constructor(private http : HttpClient){};

  /************************************************************************************************/
      /* environnements */
  /************************************************************************************************/

  getAllEnvironnements(): Observable<Environnement[]> {
    return this.http.get<Environnement[]>(this.urlEnvironnements)
      .pipe(
        tap(data => console.log(JSON.stringify(data))),
        catchError(this.handleError<Environnement[]>('getHeroes', []))
      );
  }

  getFaceSanpsById(nom : string): Observable<Environnement[]> {
    return this.getAllEnvironnements().pipe(map(fs => fs.filter(s => s.nom === nom)));
  }

  getSnapByIdWithError(nom:string):Observable<Environnement| undefined>{
   
    return this.http.get<Environnement[]>(this.urlEnvironnements)
      .pipe(
        map(templates => {
          return templates.find(template => {
            return template.nom === nom;
          })
        }),
        catchError(this.handleError<Environnement>('getSnapByIdWithError'))
      );
  }

  getSnapById(nom:string):Observable<Environnement>{
   
    return this.http.get<Environnement[]>(this.urlEnvironnements)
      .pipe(
        map(templates => {
          return templates.find(template => {
            return template.nom === nom;
          })
        })
      ) as Observable<Environnement>;

  }
  updateHero(env: Environnement): Observable<any> {
    return this.http.put(this.urlEnvironnements, env, this.httpOptions).pipe(
      catchError(this.handleError<any>('updateHero'))
    );
  }

  /************************************************************************************************/
      /* frontals */
  /************************************************************************************************/
  
  getAllFrontals(): Observable<FrontalEnv[]> {
    return this.http.get<FrontalEnv[]>(this.frontalsUrl)
      .pipe(
        tap(data => console.log(JSON.stringify(data))),
        catchError(this.handleError<FrontalEnv[]>('getFrontals', []))
      );
  }

  getFrontalByIdWithError(id:string):Observable<FrontalEnv| undefined>{
   
    return this.http.get<FrontalEnv[]>(this.frontalsUrl)
      .pipe(
        map(templates => {
          return templates.find(template => {
            return template.id === id;
          })
        }),
        catchError(this.handleError<FrontalEnv>('getFrontalByIdWithError'))
      );
  }

  /************************************************************************************************/
      /* Documents service */
  /************************************************************************************************/
  
  getDocuments(): Observable<Document[]> {
    return this.http.get<Document[]>(this.documentsUrl)
      .pipe(
        tap(data => console.log(JSON.stringify(data))),
        catchError(this.handleError<Document[]>('getDocuments', []))
      );
  }

  getDocumentByIdWithError(id:string):Observable<Document| undefined>{
   
    return this.http.get<Document[]>(this.frontalsUrl)
      .pipe(
        map(templates => {
          return templates.find(template => {
            return template.id === id;
          })
        }),
        catchError(this.handleError<Document>('getDocumentByIdWithError'))
      );
  }
  /************************************************************************************************/
      /* handler */
  /************************************************************************************************/
  private handleError<T>(operation = 'operation', result?: T) {
    return (error: any): Observable<T> => {
  
      // TODO: send the error to remote logging infrastructure
      console.error(error); // log to console instead
  
      // Let the app keep running by returning an empty result.
      return of(result as T);
    };
  }

}